% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/matching.R
\name{closest}
\alias{closest}
\alias{common}
\alias{groupRun}
\alias{joinNumeric}
\title{Relaxed Value Matching}
\usage{
closest(x, table, tolerance = Inf, duplicates = c("keep", "closest",
  "remove"), nomatch = NA_integer_)

common(x, table, tolerance = Inf, duplicates = c("keep", "closest",
  "remove"))

groupRun(x, tolerance = 0, ppm = 0)

joinNumeric(x, y, tolerance = 0, ppm = 0, join = c("outer", "left",
  "right", "inner"))
}
\arguments{
\item{x}{\code{numeric}, the values to be matched.}

\item{table}{\code{numeric}, the values to be matched against. In contrast to
\code{\link[=match]{match()}} \code{table} has to be sorted in increasing order.}

\item{tolerance}{\code{numeric}, accepted tolerance. Could be of length one or
the same length as \code{table}.}

\item{duplicates}{\code{character(1)}, how to handle duplicated matches.}

\item{nomatch}{\code{numeric(1)}, if the difference
between the value in \code{x} and \code{table} is larger than
\code{tolerance} \code{nomatch} is returned.}

\item{ppm}{For \code{groupRun}: \code{numeric(1)} representing a relative,
value-specific parts-per-million (PPM) tolerance.}

\item{y}{For \code{joinNumeric}: \code{numeric} to match values in \code{x} against.}

\item{join}{For \code{joinNumeric}: \code{character} defining the way how vectors
should be joined. Allowed are \code{"outer"}, \code{"left"}, \code{"right"} and
\code{"inner"}. See function description for details.}
}
\value{
\code{closest} returns an \code{integer} vector of the same length as \code{x}
giving the closest position in \code{table} of the first match or \code{nomatch} if
there is no match.

\code{common} returns a \code{logical} vector of length \code{x} that is \code{TRUE} if the
element in \code{x} was found in \code{table}. It is similar to \code{\link{\%in\%}}.

\code{groupRun} returns an \code{integer} indicating which elements in \code{x} are
close enough to be considered the \emph{same} (group).

\code{joinNumeric} returns a \code{list} with elements \code{x} and \code{y}, each representing
the index of the values in \code{x} matching the corresponding value in \code{y} (or
\code{NA} if the value does not match).
}
\description{
These functions offer relaxed matching of one vector in another.
In contrast to the similar \code{\link[=match]{match()}} and \code{\link{\%in\%}} functions they
just accept \code{numeric} arguments but have an additional \code{tolerance}
argument that allows relaxed matching.

\code{groupRun} groups consecutive values in \code{x} to a \emph{run} if their difference
is smaller than defined by parameters \code{tolerance} and \code{ppm}. The function
thus evaluates the differences between consecutive values and if they are
smaller than \code{< tolerance + ppm(x, ppm)} they are grouped into the same
run. In other words, if \code{x[3] - x[2]} as well as \code{x[4] - x[3]} is
\code{< tolerance + ppm(x, ppm)} they are all grouped into the same run. Note
that \code{x} is expected to be increasingly ordered.

\code{joinNumeric}: joins two \code{numeric} vectors by mapping values in \code{x} with
values in \code{y} and \emph{vice versa} if they are similar enough (provided the
\code{tolerance} and \code{ppm} specified). The function returns a list with the
indices of mapped values in \code{x} and \code{y}. Parameter \code{join} allows to define
how the vectors will be joined: \code{join = "left"}: values in \code{x} will be
mapped to values in \code{y}, elements in \code{y} not matching any value in \code{x} will
be discarded. \code{join = "right"}: same as \code{join = "left"} but for \code{y}.
\code{join = "outer"}: return matches for all values in \code{x} and in \code{y}.
\code{join = "inner"}: report only indices of values that could be mapped.
Note that at present the function will only report one index for multiple
matches (e.g. if one value in \code{x} could be mapped to more than one value
in \code{y}). A warning is displayed if multiple matches were found.
See below for examples.
}
\details{
The \code{tolerance} argument could be set to \code{0} to get the same results as for
\code{\link[=match]{match()}}. If it is set to \code{Inf} (default) the index of the closest values
is returned without any restriction.

It is not guaranteed that there is a one-to-one matching for neither the
\code{x} to \code{table} nor the \code{table} to \code{x} matching.

If multiple elements in \code{x} match a single element in \code{table} all their
corresponding indices are returned if \code{duplicates="keep"} is set (default).
This behaviour is identical to \code{\link[=match]{match()}}. For \code{duplicates="closest"} just
the closest element in \code{x} gets the corresponding index in \code{table} and
for \code{duplicates="remove"} all elements in \code{x} that match to the same element
in \code{table} are set to \code{nomatch}.

If a single element in \code{x} matches multiple elements in \code{table} the \emph{closest}
is returned for \code{duplicates="keep"} or \code{duplicates="duplicates"} (\emph{keeping}
multiple matches isn't possible in this case because the implementation relies
on \code{\link{findInterval}}). If the differences between \code{x} and the corresponding
matches in \code{table} are identical the lower index (the smaller element
in \code{table}) is returned. For \code{duplicates="remove"} all multiple matches
are returned as \code{nomatch} as above.
}
\examples{
## Define two vectors to match
x <- c(1, 3, 5)
y <- 1:10

## Compare match and closest
match(x, y)
closest(x, y)

## If there is no exact match
x <- x + 0.1
match(x, y) # no match
closest(x, y)

## Some new values
x <- c(1.11, 45.02, 556.45)
y <- c(3.01, 34.12, 45.021, 46.1, 556.449)

## Using a single tolerance value
closest(x, y, tolerance = 0.01)

## Using a value-specific tolerance accepting differences of 20 ppm
closest(x, y, tolerance = ppm(y, 20))

## Same using 50 ppm
closest(x, y, tolerance = ppm(y, 50))

## Sometimes multiple elements in `x` match to `table`
x <- c(1.6, 1.75, 1.8)
y <- 1:2
closest(x, y, tolerance = 0.5)
closest(x, y, tolerance = 0.5, duplicates = "closest")
closest(x, y, tolerance = 0.5, duplicates = "remove")

## Are there any common values?
x <- c(1.6, 1.75, 1.8)
y <- 1:2
common(x, y, tolerance = 0.5)
common(x, y, tolerance = 0.5, duplicates = "closest")
common(x, y, tolerance = 0.5, duplicates = "remove")

## Group the input values
x <- seq(1, 4, 0.1)

## Each element is it's own group
groupRun(x)

## With tolerance of 0.1 all are assigned to the same group (i.e. difference
## between consecutive elements is <= tolerance.
groupRun(x, tolerance = 0.1)

x <- 1:20
x[20] <- x[19] + ppm(x[19], 20)
groupRun(x)
groupRun(x, ppm = 20)

## Examples for joinOrderedNumeric
x <- c(1, 2, 3, 6)
y <- c(3, 4, 5, 6, 7)

## Outer joind of the two vectors
res <- joinNumeric(x, y)
res

x[res$x]
y[res$y]

## Left join: keep all from x, only those from y that match a peak in x
res <- joinNumeric(x, y, join = "left")
res

x[res$x]
y[res$y]

## If there are multiple matches, the **last** is reported
y <- c(3, 4, 5, 6, 6, 7)

res <- joinNumeric(x, y)
res

x[res$x]
y[res$y]

## Right join
res <- joinNumeric(x, y, join = "right")
res

x[res$x]
y[res$y]

## Inner join
res <- joinNumeric(x, y, join = "inner")
res

x[res$x]
y[res$y]

## More real case scenario: ppm difference.
x <- c(23.4, 34.3, 123.5, 213.6, 412.6)
y <- c(12.2, 23.5, 213.6 + ppm(213.6, 5), 237, 412.5)

res <- joinNumeric(x, y)
res

res <- joinNumeric(x, y, tolerance = 0.1, join = "outer")
res

x[res$x]
y[res$y]

res <- joinNumeric(x, y, ppm = 5, join = "inner")
res <- joinNumeric(x, rev(y), ppm = 5, join = "outer")
res <- joinNumeric(y, rev(y), ppm = 5, join = "outer")

x[res$x]
y[res$y]
}
\seealso{
\code{\link[=match]{match()}}

\code{\link{\%in\%}}
}
\author{
Sebastian Gibb, Johannes Rainer
}
