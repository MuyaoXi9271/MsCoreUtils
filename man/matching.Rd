% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/matching.R
\name{closest}
\alias{closest}
\alias{common}
\title{Relaxed Value Matching}
\usage{
closest(x, table, tolerance = Inf, duplicates = c("keep", "closest",
  "remove"), nomatch = NA_integer_)

common(x, table, tolerance = Inf, duplicates = c("keep", "closest",
  "remove"))
}
\arguments{
\item{x}{`numeric`, the values to be matched.}

\item{table}{`numeric`, the values to be matched against. In contrast to
[`match`] `table` has to be sorted in increasing order.}

\item{tolerance}{`numeric`, accepted tolerance. Use `0` to get the
same behaviour as [`match`]. Use `Inf` (default) to match to the closest
value without restrictions. Could be of length one or the same length as
`table`.}

\item{duplicates}{`character(1)`, it is possible that many `x` match one
element in `table`. For `duplicates="keep"` (default) all of them are
returned. For `duplicates="closest"` just the `x` that is closest to the
element in `table` gets an index (all the other will get `nomatch`). If the
difference is exactly identical the first one in `x` will get an index. For
`duplicates="remove"` all duplicated matches are returned as `nomatch`. If
a single element in `x` matches to multiple elements in `table` the *closest*
is returned for `duplicates="keep"` or `duplicates="duplicates"` (*keeping*
multiple matches isn't possible in this case because the implentation relies
on [`findInterval`]). If the difference is identical the index of the
smaller element in `table` is returned.
For `duplicates="remove"` all multiple matches are returned as `nomatch`.}

\item{nomatch}{`numeric(1)`, if the difference
between the value in `x` and `table` is larger than
`tolerance` `nomatch` is returned.}
}
\value{
`closest` returns an `integer` vector of the same length as `x`
giving the closest position in `table` of the first match or `nomatch` if
there is no match.

`common` returns a `logical` vector of length `x` that is `TRUE` if the
element in `x` was found in `table`. It is similar to [`%in%`].
}
\description{
These functions offer relaxed matching of one vector in another.
In contrast to the similar [`match`] and [`%in%`] functions they
just accept `numeric` arguments but have an additional `tolerance`
argument that allows relaxed matching.
}
\examples{
## Define two vectors to match
x <- c(1, 3, 5)
y <- 1:10

## Compare match and closest
match(x, y)
closest(x, y)

## If there is no exact match
x <- x + 0.1
match(x, y) # no match
closest(x, y)

## Some new values
x <- c(1.11, 45.02, 556.45)
y <- c(3.01, 34.12, 45.021, 46.1, 556.449)

## Using a single tolerance value
closest(x, y, tolerance = 0.01)

## Using a value-specific tolerance accepting differences of 20 ppm
closest(x, y, tolerance = x * ppm(20))

## Same using 50 ppm
closest(x, y, tolerance = x * ppm(50))

## Sometimes multiple elements in `x` match to `table`
x <- c(1.6, 1.75, 1.8)
y <- 1:2
closest(x, y, tolerance = 0.5)
closest(x, y, tolerance = 0.5, duplicates = "closest")
closest(x, y, tolerance = 0.5, duplicates = "remove")

## Are there common values?
x <- c(1.6, 1.75, 1.8)
y <- 1:2
common(x, y, tolerance = 0.5)
common(x, y, tolerance = 0.5, duplicates = "closest")
common(x, y, tolerance = 0.5, duplicates = "remove")
}
\seealso{
[`match`]

[`%in%`]
}
\author{
Sebastian Gibb
}
